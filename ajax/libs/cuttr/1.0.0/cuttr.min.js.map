{"version":3,"sources":["cuttr.js"],"names":["root","define","amd","factory","module","exports","Cuttr","this","el","options","self","Object","create","prototype","elementsToTruncate","originalContent","document","querySelectorAll","contentVisibilityState","contentTruncationState","truncate","length","ending","loadedClass","readMoreText","readMore","readMoreBtnPosition","readLessText","dataIndex","keys","forEach","key","truncateIt","thisElement","str","thisIndex","dataset","cuttrIndex","truncateMethod","cuttrMethod","split","splice","join","substring","currentElement","btnTag","btnAriaExpanded","addReadMore","updated","btnExists","insertAdjacentHTML","cuttrReadmore","cuttrReadless","console","cuttrReadmorePosition","cuttrReadmoreTag","readMoreBtnTag","btnSelectorClass","readMoreBtnSelectorClass","btnAdditionalClasses","cuttrReadmoreAdditionalClasses","readMoreBtnAdditionalClasses","nextElementSibling","addEventListener","btnText","replace","btnPosition","matches","target","contains","btnMarkup","updateContent","truncateLength","trancatedContent","event","classList","previousElementSibling","parentNode","currentContent","innerHTML","cuttrLength","truncateEnding","cuttrEnding","trim","i","setAttribute","push","call","init"],"mappings":"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","file":"cuttr.min.js","sourcesContent":["/*!\n * Cuttr 1.0.0\n * https://github.com\n *\n * @license GPLv3 for open source use only\n * or Cuttr Commercial License for commercial use\n * http://cuttr.kulahs.de/pricing/\n *\n * Copyright (C) 2020 http://cuttr.kulahs.de/ - A project by DEVSK\n **/\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.Cuttr = factory();\n    }\n}(this, function () {\n    const Cuttr = function (el, options){\n        'use strict';\n\n        const self = Object.create(Cuttr.prototype);\n\n        /**\n         * Default settings\n         */\n        self.options = {\n            elementsToTruncate: (el) ? document.querySelectorAll(el) : document.querySelectorAll('.cuttr'),\n            originalContent: [],\n            contentVisibilityState: [],\n            contentTruncationState: [],\n\n            //  set default options\n            truncate: 'characters', // truncate method [characters|words|sentences]\n            length: 100,  //  truncation limit\n            ending: '...',    //  truncation ending string\n            loadedClass: 'cuttr--loaded', //  class to set when truncation finished\n            readMore: false, // read more button enabled/disabled\n            readMoreText: 'read more',\n            readLessText: 'read less',\n            readMoreBtnPosition: 'after',  // [after|inside]\n            readMoreBtnTag: 'button', //  read-more button tag [button|a|...]\n            readMoreBtnSelectorClass: 'cuttr-readmore', //  read-more button selector\n            readMoreBtnAdditionalClasses: '',\n\n            //  private options\n            dataIndex: 'data-cuttr-index',   // cuttr index data attribute\n        };\n\n        /**\n         * User defined options\n         */\n        if (options) {\n            Object.keys(options).forEach(function (key){\n                self.options[key] = options[key];\n            });\n        }\n\n\n        const init = function () {\n            prepare.call(this);\n        };\n\n\n        /*\n            prepare cuttable elements\n         */\n        function prepare() {\n\n            for (let i = 0; i < self.options.elementsToTruncate.length; i++) {\n\n                const currentElement  = self.options.elementsToTruncate[i];\n                const currentContent  = currentElement.innerHTML;\n                const truncateLength  = (currentElement.dataset.cuttrLength) ? currentElement.dataset.cuttrLength : self.options.length;\n                const truncateEnding  = (currentElement.dataset.cuttrEnding) ? currentElement.dataset.cuttrEnding : self.options.ending;\n                let trancatedContent;\n\n                //  add truncate-element index to element\n                currentElement.setAttribute(self.options.dataIndex, i);\n\n                //  temporary save elements original content\n                self.options.originalContent.push(currentContent);\n\n                //  truncate content\n                trancatedContent = truncateIt(currentElement, currentContent.trim(), truncateLength, truncateEnding);\n                currentElement.innerHTML = trancatedContent;\n\n                //  add read-more button if current content is truncated\n                if (self.options.contentTruncationState[i]) {\n\n                    if (self.options.readMore)\n                        addReadMore(currentElement);\n\n                    currentElement.classList += ' ' + self.options.loadedClass;\n\n                }\n\n            }\n\n        }\n\n\n        /*\n            truncate text to specific length\n        */\n        function truncateIt(thisElement, str, length, ending) {\n\n            const thisIndex       = thisElement.dataset.cuttrIndex;\n            const truncateMethod  = (thisElement.dataset.cuttrMethod) ? thisElement.dataset.cuttrMethod : self.options.truncate;\n\n            //  set defaults\n            if (length == null) {\n                length = 100;\n            }\n\n            //  set defaults\n            if (ending == null) {\n                ending = '...';\n            }\n\n            //  truncate content based on method\n            switch (truncateMethod) {\n\n                //  truncate characters only\n                case 'characters':\n\n                    //  check if content (string) is longer than truncation limit\n                    if (str.length > length) {\n\n                        //  set current content truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n\n                        //  return new string\n                        return str.substring(0, length - ending.length) + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate words\n                case 'words':\n\n                    const words = str.split(' ');\n\n                    //  check if content (string) is longer than truncation limit\n                    if (words.length > length) {\n\n                        //  set current contetn truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        return str.split(' ').splice(0,length).join(' ') + ' ' + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate full sentences\n                case 'sentences':\n\n                    const sentences = str.split('. ');\n\n                    //  check if content (string) is longer than truncation limit\n                    if (sentences.length > length) {\n\n                        //  set current contetn truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        return str.split('. ').splice(0,length).join('. ') + '. ' + ending + ' ';\n\n                    } else {\n                        return str;\n                    }\n\n                    break;\n\n                //  truncate by height - https://stackoverflow.com/questions/11965291/how-to-truncate-text-with-respect-to-div-height#answer-30204260\n\n                //  truncate characters by default\n                default:\n\n                    //  check if content (string) is longer than truncation limit\n                    if (str.length > length) {\n\n                        //  set current contetn truncation true and return truncated string\n                        self.options.contentTruncationState[thisIndex] = true;\n                        //  set visibility state\n                        self.options.contentVisibilityState[thisIndex] = false;\n                        //  return new string\n                        return str.substring(0, length - ending.length) + ending;\n\n                    } else {\n                        return str;\n                    }\n\n            }\n\n        }\n\n\n        /*\n            append read more button\n        */\n        function addReadMore(thisElement, updated) {\n\n            const currentElement      = thisElement;\n            const thisIndex           = currentElement.dataset.cuttrIndex;\n            const readMoreText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadmore : self.options.readMoreText;\n            const readLessText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadless : self.options.readLessText;\n            const btnPosition         = (currentElement.dataset.cuttrReadmorePosition) ? currentElement.dataset.cuttrReadmorePosition : self.options.readMoreBtnPosition;\n            const btnTag              = (currentElement.dataset.cuttrReadmoreTag) ? currentElement.dataset.cuttrReadmoreTag : self.options.readMoreBtnTag;\n            const btnSelectorClass    = '.' + self.options.readMoreBtnSelectorClass;\n            const btnAdditionalClasses = (currentElement.dataset.cuttrReadmoreAdditionalClasses) ? currentElement.dataset.cuttrReadmoreAdditionalClasses : self.options.readMoreBtnAdditionalClasses;\n            const btnText             = (self.options.contentVisibilityState[thisIndex]) ? readLessText : readMoreText;\n            const btnAriaExpanded     = (self.options.contentVisibilityState[thisIndex]) ? 'true' : 'false';\n            const btnMarkup           = ' <' + btnTag + ' aria-expanded=\"' + btnAriaExpanded + '\" class=\"' + self.options.readMoreBtnSelectorClass + ' ' + btnAdditionalClasses + '\">' + btnText.replace(/<[^>]*>/g, \"\") + '</' + btnTag + '>';\n            let btnExists;\n\n            //  check for button existence depending on btn position\n            if (btnPosition == 'after' && currentElement.nextElementSibling) {\n                btnExists = currentElement.nextElementSibling.matches(btnSelectorClass);\n            } else if (btnPosition == 'inside') {\n                btnExists = currentElement.querySelector(btnSelectorClass);\n            }\n\n            //  insert element only if it doesn't exist\n            if (!btnExists) {\n\n                //  add read-more button to dom\n                switch (btnPosition) {\n                    case 'after':\n                        currentElement.insertAdjacentHTML('afterend', btnMarkup);\n                        break;\n                    case 'inside':\n                        currentElement.insertAdjacentHTML('beforeend', btnMarkup);\n                        break;\n                    default:\n                        console.log('no matching read-more button position defined');\n                }\n\n                //  listen to read-more clicks - show/hide content\n                if (!updated) {\n\n                    if (btnPosition == 'after') {\n                        currentElement.nextElementSibling.addEventListener('click',function(event) {\n                            if (event.target && event.target.classList.contains(self.options.readMoreBtnSelectorClass)) {\n                                updateContent(event, btnPosition);\n                            }\n                        });\n                    } else if (btnPosition == 'inside') {\n                        currentElement.addEventListener('click',function(event) {\n                            if (event.target && event.target.classList.contains(self.options.readMoreBtnSelectorClass)) {\n                                updateContent(event, btnPosition);\n                            }\n                        });\n                    }\n\n                }\n\n            }\n\n        }\n\n\n        /*\n            display original/truncated content\n        */\n        function updateContent(event, btnPosition) {\n\n            const currentElement      = (btnPosition == 'after') ? event.target.previousElementSibling : event.target.parentNode;\n            const currentContent      = currentElement.innerHTML;\n            const thisIndex           = currentElement.dataset.cuttrIndex;\n            const readMoreText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadmore : self.options.readMoreText;\n            const readLessText        = (currentElement.dataset.cuttrReadmore) ? currentElement.dataset.cuttrReadless : self.options.readLessText;\n            const truncateLength      = (currentElement.dataset.cuttrLength) ? currentElement.dataset.cuttrLength : self.options.length;\n            const truncateEnding      = (currentElement.dataset.cuttrEnding) ? currentElement.dataset.cuttrEnding : self.options.ending;\n            let trancatedContent;\n\n            //  show content if its currently truncated\n            if (!self.options.contentVisibilityState[thisIndex]) {\n\n                //  replace content with original content from element at specific index\n                currentElement.innerHTML = self.options.originalContent[thisIndex];\n\n                //  set visibility state\n                self.options.contentVisibilityState[thisIndex] = true;\n\n                if (btnPosition == 'inside' && self.options.readMore)\n                    addReadMore(currentElement, true);\n\n                //  update button text and aria\n                event.target.innerHTML = readLessText.replace(/<[^>]*>/g, \"\");\n                //event.target.setAttribute('aria-expanded', 'true');\n\n                //  truncate content if its shown completely currently\n            } else {\n\n                //  truncate content\n                trancatedContent = truncateIt(currentElement, currentContent.trim(), truncateLength, truncateEnding);\n                currentElement.innerHTML = trancatedContent;\n\n                //  set visibility state\n                self.options.contentVisibilityState[thisIndex] = false;\n\n                if (btnPosition == 'inside' && self.options.readMore)\n                    addReadMore(currentElement, true);\n\n                //  update button text and aria\n                event.target.innerHTML = readMoreText.replace(/<[^>]*>/g, \"\");\n                //event.target.setAttribute('aria-expanded', 'false');\n\n            }\n\n        }\n\n        init();\n        return self;\n    };\n    return Cuttr;\n}));"]}