"use strict";const doT={templateSettings:{argName:"it",encoders:{},selfContained:!1,strip:!0,internalPrefix:"_val",encodersPrefix:"_enc",delimiters:{start:"{{",end:"}}"}},template:template,compile:compile,setDelimiters:setDelimiters};module.exports=doT;const encoderType={false:"function",true:"string"},defaultSyntax={evaluate:/\{\{([\s\S]+?(\}?)+)\}\}/g,interpolate:/\{\{=([\s\S]+?)\}\}/g,typeInterpolate:/\{\{%([nsb])=([\s\S]+?)\}\}/g,encode:/\{\{([a-z_$]+[\w$]*)?!([\s\S]+?)\}\}/g,use:/\{\{#([\s\S]+?)\}\}/g,useParams:/(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$]+(?:\.[\w$]+|\[[^\]]+\])*|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,define:/\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,defineParams:/^\s*([\w$]+):([\s\S]+)/,conditional:/\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,iterate:/\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g};let currentSyntax={...defaultSyntax};const TYPES={n:"number",s:"string",b:"boolean"};function resolveDefs(e,t,n,r){return("string"==typeof n?n:n.toString()).replace(t.define,(e,n,s,o)=>(0===n.indexOf("def.")&&(n=n.substring(4)),n in r||(":"===s?(o.replace(t.defineParams,(e,t,s)=>{r[n]={arg:t,text:s}}),n in r||(r[n]=o)):new Function("def",`def['${n}']=${o}`)(r)),"")).replace(t.use,(n,s)=>{s=s.replace(t.useParams,(e,t,n,s)=>{if(r[n]&&r[n].arg&&s){const e=unescape((n+":"+s).replace(/'|\\/g,"_"));return r.__exp=r.__exp||{},r.__exp[e]=r[n].text.replace(new RegExp(`(^|[^\\w$])${r[n].arg}([^\\w$])`,"g"),`$1${s}$2`),t+`def.__exp['${e}']`}});const o=new Function("def","return "+s)(r);return o?resolveDefs(e,t,o,r):o})}function unescape(e){return e.replace(/\\('|\\)/g,"$1").replace(/[\r\t\n]/g," ")}function template(e,t,n){const r=t&&t.delimiters,s=r&&!sameDelimiters(r)?getSyntax(r):currentSyntax;t=t?{...doT.templateSettings,...t}:doT.templateSettings;let o=0,c=resolveDefs(t,s,e,n||{});const a={};c=("let out='"+(t.strip?c.trim().replace(/[\t ]+(\r|\n)/g,"\n").replace(/(\r|\n)[\t ]+/g," ").replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""):c).replace(/'|\\/g,"\\$&").replace(s.interpolate,(e,t)=>`'+(${unescape(t)})+'`).replace(s.typeInterpolate,(e,n,r)=>{o++;const s=t.internalPrefix+o,c=`throw new Error("expected ${TYPES[n]}, got "+ (typeof ${s}))`;return`';const ${s}=(${unescape(r)});if(typeof ${s}!=="${TYPES[n]}") ${c};out+=${s}+'`}).replace(s.encode,(e,n="",r)=>{a[n]=!0,r=unescape(r);const s=t.selfContained?n:n?"."+n:'[""]';return`'+${t.encodersPrefix}${s}(${r})+'`}).replace(s.conditional,(e,t,n)=>n?(n=unescape(n),t?`';}else if(${n}){out+='`:`';if(${n}){out+='`):t?"';}else{out+='":"';}out+='").replace(s.iterate,(e,n,r,s)=>{if(!n)return"';} } out+='";o++;const c=s?`let ${s}=-1;`:"",a=s?`${s}++;`:"",i=t.internalPrefix+o;return`';const ${i}=${unescape(n)};if(${i}){${c}for (const ${r} of ${i}){${a}out+='`}).replace(s.evaluate,(e,t)=>`';${unescape(t)}out+='`)+"';return out;").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r").replace(/(\s|;|\}|^|\{)out\+='';/g,"$1").replace(/\+''/g,"");const i=Array.isArray(t.argName)?properties(t.argName):t.argName;return 0===Object.keys(a).length?l(()=>new Function(i,c)):(checkEncoders(t,a),c=`return function(${i}){${c}};`,l(()=>t.selfContained?new Function(c=addEncoders(t,a)+c)():new Function(t.encodersPrefix,c)(t.encoders)));function l(e){try{return e()}catch(e){throw console.log("Could not create a template function: "+c),e}}}function compile(e,t){return template(e,null,t)}function sameDelimiters({start:e,end:t}){const n=doT.templateSettings.delimiters;return n.start===e&&n.end===t}function setDelimiters(e){sameDelimiters(e)?console.log("delimiters did not change"):(currentSyntax=getSyntax(e),doT.templateSettings.delimiters=e)}function getSyntax({start:e,end:t}){e=escape(e),t=escape(t);const n={};for(const r in defaultSyntax){const s=defaultSyntax[r].toString().replace(/\\\{\\\{/g,e).replace(/\\\}\\\}/g,t);n[r]=strToRegExp(s)}return n}const escapeCharacters=/([{}[\]()<>\\\/^$\-.+*?!=|&:])/g;function escape(e){return e.replace(escapeCharacters,"\\$1")}const regexpPattern=/^\/(.*)\/([\w]*)$/;function strToRegExp(e){const[,t,n]=e.match(regexpPattern);return new RegExp(t,n)}function properties(e){return e.reduce((e,t,n)=>e+(n?",":"")+t,"{")+"}"}function checkEncoders(e,t){const n=encoderType[e.selfContained];for(const r in t){const t=e.encoders[r];if(!t)throw new Error(`unknown encoder "${r}"`);if(typeof t!==n)throw new Error(`selfContained ${e.selfContained}: encoder type must be "${n}"`)}}function addEncoders(e,t){let n="";for(const r in t)n+=`const ${e.encodersPrefix}${r}=${e.encoders[r]};`;return n}