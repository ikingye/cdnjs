import{EventEmitter}from"../EventEmitter";const hasOwn=Object.prototype.hasOwnProperty;export class ObservableMap extends EventEmitter{constructor(e,t){if(super(),this._entries=new Map,t&&t.valueEquals&&(this._valueEquals=t.valueEquals),e){let t=this._entries;if(e instanceof Map||e instanceof ObservableMap)for(let[s,r]of e instanceof Map?e:e._entries)t.set(s,r);else if(Array.isArray(e))for(let s=0,r=e.length;s<r;s++)t.set(e[s][0],e[s][1]);else for(let s in e)hasOwn.call(e,s)&&t.set(s,e[s])}}get size(){return this._entries.size}get valueEquals(){return this._valueEquals}onChange(e,t){return this.on(ObservableMap.EVENT_CHANGE,e,t)}offChange(e,t){return this.off(ObservableMap.EVENT_CHANGE,e,t)}has(e){return this._entries.has(e)}get(e){return this._entries.get(e)}set(e,t){let s,r=this._entries,a=r.has(e);return a&&(s=r.get(e),Object.is(t,s))?this:(r.set(e,t),this.emit(ObservableMap.EVENT_CHANGE,{subtype:a?"update":"add",key:e,prevValue:s,value:t}),this)}delete(e){let t=this._entries;if(t.has(e)){let s=t.get(e);return t.delete(e),this.emit(ObservableMap.EVENT_CHANGE,{subtype:"delete",key:e,value:s}),!0}return!1}clear(){return this._entries.size&&(this._entries.clear(),this.emit(ObservableMap.EVENT_CHANGE,{subtype:"clear"})),this}equals(e){if(!(e instanceof ObservableMap))return!1;if(this.size!=e.size)return!1;for(let[t,s]of this){if(!e.has(t))return!1;let r=e.get(t);if(this._valueEquals||e._valueEquals?!(this._valueEquals||e._valueEquals)(s,r):s!==r&&!(s&&r&&"object"==typeof s&&"object"==typeof r&&s.equals&&s.equals===r.equals&&s.equals(r)))return!1}return!0}forEach(e,t){for(let[s,r]of this._entries)e.call(t,r,s,this)}keys(){return this._entries.keys()}values(){return this._entries.values()}entries(){return this._entries.entries()}clone(e=!1){let t;if(e){t=[];for(let[e,s]of this._entries)t.push([e,s&&"object"==typeof s&&s.clone?s.clone(!0):s])}return new this.constructor(t||this)}absorbFrom(e){if(!(e instanceof ObservableMap))throw TypeError('"that" must be instance of ObservableMap');let t=this._entries,s=!1;for(let[r,a]of t)if(e.has(r)){let l=e.get(r);(this._valueEquals||e._valueEquals?(this._valueEquals||e._valueEquals)(a,l):a===l||a&&l&&"object"==typeof a&&"object"==typeof l&&a.equals&&a.equals===l.equals&&a.equals(l))||(a&&l&&"object"==typeof a&&"object"==typeof l&&a.absorbFrom&&a.absorbFrom===l.absorbFrom?a.absorbFrom(l)&&(s=!0):(t.set(r,l),s=!0))}else t.delete(r),s=!0;for(let[r,a]of e)t.has(r)||(t.set(r,a),s=!0);return s&&this.emit(ObservableMap.EVENT_CHANGE,{subtype:"absorbFrom"}),s}toData(){let e={};for(let[t,s]of this._entries)e[t]=s&&"object"==typeof s&&s.toData?s.toData():s;return e}};ObservableMap.EVENT_CHANGE="change",ObservableMap.prototype[Symbol.iterator]=ObservableMap.prototype.entries;