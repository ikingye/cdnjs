export const version="1.1.0";const _BI="function"==typeof BigInt?BigInt:Number,_crop=t=>t<=Number.MAX_SAFE_INTEGER?Number(t):_BI(t);export function permutation(t,e){[t,e]=[_BI(t),_BI(e)];let s=_BI(1);for(;e--;)s*=t--;return _crop(s)};export function combination(t,e){const s=permutation,r=_BI(s(t,e))/_BI(s(e,e));return _crop(r)};export function factorial(t){return permutation(t,t)};export function factoradic(t,e=0){let[s,r]=[_BI(t),_BI(1)];if(e)r=_BI(factorial(e));else{for(e=1;r<s;r*=_BI(++e));s<r&&(r/=_BI(e--))}let i=[0];for(;e;r/=_BI(e--))i[e]=Math.floor(Number(s/r)),s%=r;return i};class _CBase{static make(...t){return new(Function.prototype.bind.apply(this,[null].concat(t)))}static vmake(t){return new(Function.prototype.bind.apply(this,[null].concat(t)))}[Symbol.iterator](){return function*(t,e){let s=0;for(;s<t;)yield e.nth(s++)}(this.length,this)}toArray(){return[...this]}get isBig(){return Number.MAX_SAFE_INTEGER<this.length}get isSafe(){return"undefined"!=typeof BigInt||!this.isBig}_check(t){if(t<0){if(this.length<-t)throw RangeError(`${t} is too small`);return _crop(_BI(this.length)+_BI(t))}if(this.length<=t)throw RangeError(`${t} is too large`);return t}}export class Permutation extends _CBase{constructor(t,e=0){super(),this.seed=[...t],this.size=0<e&&e<=this.seed.length?e:this.seed.length,this.length=permutation(t.length,this.size),Object.freeze(this)}nth(t,e=!1){e||(t=this._check(t));const s=this.seed.length-this.size,r=factorial(s);let i=factoradic(_BI(t)*_BI(r),this.seed.length),n=this.seed.slice(),o=[];for(let t=this.seed.length-1;s<=t;t--)o.push(n.splice(i[t],1)[0]);return o}};export class Combination extends _CBase{constructor(t,e=0){super(),this.perm=new Permutation([...t],e),this.size=this.perm.size,this.length=combination(t.length,this.size),Object.freeze(this)}nth(t){return t=this._check(t),this.perm.nth(function(t){const[e,s]="bigint"==typeof t?[_BI(1),_BI(2)]:[1,2];if(t<=s)return t;let r=t-e,i=r&-r,n=r+i;return n|((n&-n)/i>>e)-e}(t),!0)}};export class BaseN extends _CBase{constructor(t,e){super(),e||(e=1),this.seed=[...t],this.size=e;let s=this.seed.length;this.base=s;let r=Array(e).fill(_BI(s)).reduce((t,e)=>t*e);this.length=_crop(r),Object.freeze(this)}nth(t){const e="bigint"==typeof(t=this._check(t))?_BI(this.base):this.base;let s=[];for(let i=0;i<this.size;i++){var r=t%e;s.push(this.seed[r]),t-=r,t/=e}return s}};export class PowerSet extends _CBase{constructor(t){super(),this.seed=t;const e=_BI(1)<<_BI(this.seed.length);this.length=_crop(e),Object.freeze(this)}nth(t){if((t=this._check(t))<0)throw RangeError(`${t} is too small`);if(this.length<=t)throw RangeError(`${t} is out of range`);const e="bigint"==typeof t?_BI(1):1;let s=[];for(let r=0;t;t>>=e,r++)t&e&&s.push(this.seed[r]);return s}};export class CartesianProduct extends _CBase{constructor(...t){super(),this.seed=t.map(t=>[...t]),this.size=this.seed.length;const e=this.seed.reduce((t,e)=>t*_BI(e.length),_BI(1));this.length=_crop(e),Object.freeze(this)}nth(t){if((t=this._check(t))<0)throw RangeError(`${t} is too small`);if(this.length<=t)throw RangeError(`${t} is out of range`);let e=[];for(let s=0;s<this.size;s++){const r=this.seed[s].length,i="bigint"==typeof t?_BI(r):r,n=t%i;e.push(this.seed[s][Number(n)]),t-=n,t/=i}return e}};