export const version="1.0.0";const _BI="function"==typeof BigInt?BigInt:Number;export function permutation(t,e){[t,e]=[_BI(t),_BI(e)];let s=_BI(1);for(;e--;)s*=t--;return s<=Number.MAX_SAFE_INTEGER?Number(s):s};export function combination(t,e){const s=permutation,r=_BI(s(t,e))/_BI(s(e,e));return r<=Number.MAX_SAFE_INTEGER?Number(r):r};export function factorial(t){return permutation(t,t)};export function factoradic(t,e=0){let[s,r]=[_BI(t),_BI(1)];if(e)r=_BI(factorial(e));else{for(e=1;r<s;r*=_BI(++e));s<r&&(r/=_BI(e--))}let i=[0];for(;e;r/=_BI(e--))i[e]=Math.floor(Number(s/r)),s%=r;return i};class _CBase{static make(...t){return new(Function.prototype.bind.apply(this,[null].concat(t)))}static vmake(t){return new(Function.prototype.bind.apply(this,[null].concat(t)))}[Symbol.iterator](){return function*(t,e){let s=0;for(;s<t;)yield e.nth(s++)}(this.length,this)}toArray(){return[...this]}get isBig(){return Number.MAX_SAFE_INTEGER<this.length}get isSafe(){return"undefined"!=typeof BigInt||!this.isBig}}export class Permutation extends _CBase{constructor(t,e=0){super(),this.seed=[...t],this.size=0<e&&e<=this.seed.length?e:this.seed.length,this.length=permutation(t.length,this.size),Object.freeze(this)}nth(t){const e=this.seed.length-this.size,s=factorial(e);let r=factoradic(_BI(t)*_BI(s),this.seed.length),i=this.seed.slice(),n=[];for(let t=this.seed.length-1;e<=t;t--)n.push(i.splice(r[t],1)[0]);return n}};export class Combination extends _CBase{constructor(t,e=0){super(),this.perm=new Permutation([...t],e),this.size=this.perm.size,this.length=combination(t.length,this.size),Object.freeze(this)}nth(t){return this.perm.nth(function(t){const[e,s]="bigint"==typeof t?[_BI(1),_BI(2)]:[1,2];if(t<=s)return t;let r=t-e,i=r&-r,n=r+i;return n|((n&-n)/i>>e)-e}(t))}};export class BaseN extends _CBase{constructor(t,e){super(),e||(e=1),this.seed=[...t],this.size=e;let s=this.seed.length;this.base=s;let r=Array(e).fill(_BI(s)).reduce((t,e)=>t*e);this.length=r<=Number.MAX_SAFE_INTEGER?Number(r):r,Object.freeze(this)}nth(t){if(t<0)throw RangeError(`${t} is too small`);if(this.length<=t)throw RangeError(`${t} is too large`);const e="bigint"==typeof t?_BI(this.base):this.base;let s=[];for(let i=0;i<this.size;i++){var r=t%e;s.push(this.seed[r]),t-=r,t/=e}return s}};export class PowerSet extends _CBase{constructor(t){super(),this.seed=t;const e=_BI(1)<<_BI(this.seed.length);this.length=e<=Number.MAX_SAFE_INTEGER?Number(e):e,Object.freeze(this)}nth(t){if(t<0)throw RangeError(`${t} is too small`);if(this.length<=t)throw RangeError(`${t} is too large`);const e="bigint"==typeof t?_BI(1):1;let s=[];for(let r=0;t;t>>=e,r++)t&e&&s.push(this.seed[r]);return s}};export class CartesianProduct extends _CBase{constructor(...t){super(),this.seed=t.map(t=>[...t]),this.size=this.seed.length;const e=this.seed.reduce((t,e)=>t*_BI(e.length),_BI(1));this.length=e<=Number.MAX_SAFE_INTEGER?Number(e):e,Object.freeze(this)}nth(t){if(t<0)throw RangeError(`${t} is too small`);if(this.length<=t)throw RangeError(`${t} is too large`);let e=[];for(let s=0;s<this.size;s++){const r=this.seed[s].length,i="bigint"==typeof t?_BI(r):r,n=t%i;e.push(this.seed[s][Number(n)]),t-=n,t/=i}return e}};