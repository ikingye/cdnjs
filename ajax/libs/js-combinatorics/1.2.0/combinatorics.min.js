export const version="1.2.0";const _BI="function"==typeof BigInt?BigInt:Number,_crop=t=>t<=Number.MAX_SAFE_INTEGER?Number(t):_BI(t);export function permutation(t,e){[t,e]=[_BI(t),_BI(e)];let s=_BI(1);for(;e--;)s*=t--;return _crop(s)};export function combination(t,e){const s=permutation,r=_BI(s(t,e))/_BI(s(e,e));return _crop(r)};export function factorial(t){return permutation(t,t)};export function factoradic(t,e=0){let[s,r]=[_BI(t),_BI(1)];if(e)r=_BI(factorial(e));else{for(e=1;r<s;r*=_BI(++e));s<r&&(r/=_BI(e--))}let i=[0];for(;e;r/=_BI(e--))i[e]=Math.floor(Number(s/r)),s%=r;return i};class _CBase{static make(...t){return new(Function.prototype.bind.apply(this,[null].concat(t)))}static vmake(t){return new(Function.prototype.bind.apply(this,[null].concat(t)))}[Symbol.iterator](){return function*(t,e){let s=0;for(;s<t;)yield e.nth(s++)}(this.length,this)}toArray(){return[...this]}get isBig(){return Number.MAX_SAFE_INTEGER<this.length}get isSafe(){return"undefined"!=typeof BigInt||!this.isBig}_check(t){if(t<0){if(this.length<-t)throw RangeError(`${t} is too small`);return _crop(_BI(this.length)+_BI(t))}if(this.length<=t)throw RangeError(`${t} is too large`);return t}nth(t){return[]}}export class Permutation extends _CBase{constructor(t,e=0){super(),this.seed=[...t],this.size=0<e&&e<=this.seed.length?e:this.seed.length,this.length=permutation(t.length,this.size),Object.freeze(this)}nth(t,e=!1){e||(t=this._check(t));const s=this.seed.length-this.size,r=factorial(s);let i=factoradic(_BI(t)*_BI(r),this.seed.length),n=this.seed.slice(),h=[];for(let t=this.seed.length-1;s<=t;t--)h.push(n.splice(i[t],1)[0]);return h}};export class Combination extends _CBase{constructor(t,e=0){super();const s=[...t];this.perm=new Permutation(s,e),this.size=this.perm.size,this.length=combination(s.length,this.size),Object.freeze(this)}nth(t){return t=this._check(t),this.perm.nth(function(t){const[e,s]="bigint"==typeof t?[_BI(1),_BI(2)]:[1,2];if(t<=s)return t;let r=t-e,i=r&-r,n=r+i;return n|((n&-n)/i>>e)-e}(t),!0)}};export class BaseN extends _CBase{constructor(t,e=1){super(),this.seed=[...t],this.size=e;let s=this.seed.length;this.base=s;let r=e<1?0:Array(e).fill(_BI(s)).reduce((t,e)=>t*e);this.length=_crop(r),Object.freeze(this)}nth(t){let e=_BI(this._check(t));const s=_BI(this.base);let r=[];for(let t=0;t<this.size;t++){var i=e%s;r.push(this.seed[Number(i)]),e-=i,e/=s}return r}};export class PowerSet extends _CBase{constructor(t){super(),this.seed=[...t];const e=_BI(1)<<_BI(this.seed.length);this.length=_crop(e),Object.freeze(this)}nth(t){let e=_BI(this._check(t)),s=[];for(let t=_BI(0);e;e>>=_BI(1),t++)e&_BI(1)&&s.push(this.seed[Number(t)]);return s}};export class CartesianProduct extends _CBase{constructor(...t){super(),this.seed=t.map(t=>[...t]),this.size=this.seed.length;const e=this.seed.reduce((t,e)=>t*_BI(e.length),_BI(1));this.length=_crop(e),Object.freeze(this)}nth(t){let e=_BI(this._check(t)),s=[];for(let t=0;t<this.size;t++){const r=this.seed[t].length,i=_BI(r),n=e%i;s.push(this.seed[t][Number(n)]),e-=n,e/=i}return s}};