"use strict";exports.__esModule=!0,exports.RECEIVE_MESSAGE_TYPES=void 0;var _src=require("zalgo-promise/src"),_src2=require("cross-domain-utils/src"),_src3=require("belter/src"),_conf=require("../../conf"),_send=require("../send"),_listeners=require("../listeners");const RECEIVE_MESSAGE_TYPES={[_conf.MESSAGE_TYPE.REQUEST](e,r,o,{on:n,send:s}){const i=(0,_listeners.getRequestListener)({name:o.name,win:e,domain:r}),t=o.name===_conf.MESSAGE_NAME.METHOD&&o.data&&"string"==typeof o.data.name?`${o.data.name}()`:o.name;function a(i,a,c){return _src.ZalgoPromise.flush().then(()=>{if(!o.fireAndForget&&!(0,_src2.isWindowClosed)(e)){__DEBUG__&&(i===_conf.MESSAGE_ACK.SUCCESS?console.info("respond::res",t,r,"\n\n",a):i===_conf.MESSAGE_ACK.ERROR&&console.error("respond::err",t,r,"\n\n",c));try{return(0,_send.sendMessage)(e,r,{id:(0,_src3.uniqueID)(),origin:(0,_src2.getDomain)(window),type:_conf.MESSAGE_TYPE.RESPONSE,hash:o.hash,name:o.name,ack:i,data:a,error:c},{on:n,send:s})}catch(e){throw new Error(`Send response message failed for ${t} in ${(0,_src2.getDomain)()}\n\n${(0,_src3.stringifyError)(e)}`)}}})}return __DEBUG__&&console.info("receive::req",t,r,"\n\n",o.data),_src.ZalgoPromise.all([_src.ZalgoPromise.flush().then(()=>{if(!o.fireAndForget&&!(0,_src2.isWindowClosed)(e))try{return(0,_send.sendMessage)(e,r,{id:(0,_src3.uniqueID)(),origin:(0,_src2.getDomain)(window),type:_conf.MESSAGE_TYPE.ACK,hash:o.hash,name:o.name},{on:n,send:s})}catch(e){throw new Error(`Send ack message failed for ${t} in ${(0,_src2.getDomain)()}\n\n${(0,_src3.stringifyError)(e)}`)}}),_src.ZalgoPromise.try(()=>{if(!i)throw new Error(`No handler found for post message: ${o.name} from ${r} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`);if(!(0,_src2.matchDomain)(i.domain,r))throw new Error(`Request origin ${r} does not match domain ${i.domain.toString()}`);const n=o.data;return i.handler({source:e,origin:r,data:n})}).then(e=>a(_conf.MESSAGE_ACK.SUCCESS,e),e=>a(_conf.MESSAGE_ACK.ERROR,null,e))]).then(_src3.noop).catch(e=>{if(i&&i.handleError)return i.handleError(e);throw e})},[_conf.MESSAGE_TYPE.ACK](e,r,o){if((0,_listeners.isResponseListenerErrored)(o.hash))return;const n=(0,_listeners.getResponseListener)(o.hash);if(!n)throw new Error(`No handler found for post message ack for message: ${o.name} from ${r} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`);try{if(!(0,_src2.matchDomain)(n.domain,r))throw new Error(`Ack origin ${r} does not match domain ${n.domain.toString()}`);if(e!==n.win)throw new Error("Ack source does not match registered window")}catch(e){n.promise.reject(e)}n.ack=!0},[_conf.MESSAGE_TYPE.RESPONSE](e,r,o){if((0,_listeners.isResponseListenerErrored)(o.hash))return;const n=(0,_listeners.getResponseListener)(o.hash);if(!n)throw new Error(`No handler found for post message response for message: ${o.name} from ${r} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`);if(!(0,_src2.matchDomain)(n.domain,r))throw new Error(`Response origin ${r} does not match domain ${(0,_src2.stringifyDomainPattern)(n.domain)}`);if(e!==n.win)throw new Error("Response source does not match registered window");(0,_listeners.deleteResponseListener)(o.hash);const s=o.name===_conf.MESSAGE_NAME.METHOD&&o.data&&"string"==typeof o.data.name?`${o.data.name}()`:o.name;o.ack===_conf.MESSAGE_ACK.ERROR?(__DEBUG__&&console.error("receive::err",s,r,"\n\n",o.error),n.promise.reject(o.error)):o.ack===_conf.MESSAGE_ACK.SUCCESS&&(__DEBUG__&&console.info("receive::res",s,r,"\n\n",o.data),n.promise.resolve({source:e,origin:r,data:o.data}))}};exports.RECEIVE_MESSAGE_TYPES=RECEIVE_MESSAGE_TYPES;