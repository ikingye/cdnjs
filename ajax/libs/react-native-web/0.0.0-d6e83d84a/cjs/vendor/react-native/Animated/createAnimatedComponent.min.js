"use strict";exports.__esModule=!0,exports.default=void 0;var _AnimatedEvent=require("./AnimatedEvent"),_AnimatedProps=_interopRequireDefault(require("./nodes/AnimatedProps")),_react=_interopRequireDefault(require("react")),_invariant=_interopRequireDefault(require("fbjs/lib/invariant")),_setAndForwardRef=_interopRequireDefault(require("../../../modules/setAndForwardRef"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}function _extends(){return(_extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}).apply(this,arguments)}function _inheritsLoose(e,t){e.prototype=Object.create(t.prototype),(e.prototype.constructor=e).__proto__=t}function createAnimatedComponent(n,a){(0,_invariant.default)("function"!=typeof n||n.prototype&&n.prototype.isReactComponent,"`createAnimatedComponent` does not support stateless functional components; use a class component instead.");var o=function(t){function o(e){var n=t.call(this,e)||this;return n._invokeAnimatedPropsCallbackOnMount=!1,n._eventDetachers=[],n._animatedPropsCallback=function(){if(null==n._component)n._invokeAnimatedPropsCallbackOnMount=!0;else if(o.__skipSetNativeProps_FOR_TESTS_ONLY||"function"!=typeof n._component.setNativeProps)n.forceUpdate();else{if(n._propsAnimated.__isNative)throw new Error('Attempting to run JS driven animation on animated node that has been moved to "native" earlier by starting an animation with `useNativeDriver: true`');n._component.setNativeProps(n._propsAnimated.__getAnimatedValue())}},n._setComponentRef=(0,_setAndForwardRef.default)({getForwardedRef:function(){return n.props.forwardedRef},setLocalRef:function(t){n._prevComponent=n._component,null!=(n._component=t)&&null==t.getNode&&(t.getNode=function(){var e;return console.warn("%s: Calling `getNode()` on the ref of an Animated component is no longer necessary. You can now directly use the ref instead. This method will be removed in a future release.",null!==(e=t.constructor.name)&&void 0!==e?e:"<<anonymous>>"),t})}}),n}_inheritsLoose(o,t);var e=o.prototype;return e.componentWillUnmount=function(){this._propsAnimated&&this._propsAnimated.__detach(),this._detachNativeEvents()},e.UNSAFE_componentWillMount=function(){this._attachProps(this.props)},e.componentDidMount=function(){this._invokeAnimatedPropsCallbackOnMount&&(this._invokeAnimatedPropsCallbackOnMount=!1,this._animatedPropsCallback()),this._propsAnimated.setNativeView(this._component),this._attachNativeEvents()},e._attachNativeEvents=function(){function e(e){var t=n.props[e];t instanceof _AnimatedEvent.AnimatedEvent&&t.__isNative&&(t.__attach(o,e),n._eventDetachers.push(function(){return t.__detach(o,e)}))}var n=this,o=this._component&&this._component.getScrollableNode?this._component.getScrollableNode():this._component;for(var t in this.props)e(t)},e._detachNativeEvents=function(){this._eventDetachers.forEach(function(e){return e()}),this._eventDetachers=[]},e._attachProps=function(e){var t=this._propsAnimated;this._propsAnimated=new _AnimatedProps.default(e,this._animatedPropsCallback),t&&t.__detach()},e.UNSAFE_componentWillReceiveProps=function(e){this._attachProps(e)},e.componentDidUpdate=function(e){this._component!==this._prevComponent&&this._propsAnimated.setNativeView(this._component),this._component===this._prevComponent&&e===this.props||(this._detachNativeEvents(),this._attachNativeEvents())},e.render=function(){var e=this._propsAnimated.__getValue();return _react.default.createElement(n,_extends({},a,e,{ref:this._setComponentRef,collapsable:!1}))},o}(_react.default.Component);o.__skipSetNativeProps_FOR_TESTS_ONLY=!1;n.propTypes;return _react.default.forwardRef(function(e,t){return _react.default.createElement(o,_extends({},e,null==t?null:{forwardedRef:t}))})}var _default=createAnimatedComponent;exports.default=createAnimatedComponent,module.exports=exports.default;