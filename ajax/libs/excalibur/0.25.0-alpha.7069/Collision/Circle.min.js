import{BoundingBox}from"./BoundingBox";import{CollisionJumpTable}from"./CollisionJumpTable";import{ConvexPolygon}from"./ConvexPolygon";import{Edge}from"./Edge";import{Vector,Projection}from"../Algebra";import{Physics}from"../Physics";import{Color}from"../Drawing/Color";import{ClosestLineJumpTable}from"./ClosestLineJumpTable";var Circle=function(){function t(t){this.offset=Vector.Zero,this.offset=t.offset||Vector.Zero,this.radius=t.radius||0,this.collider=t.collider||null}return Object.defineProperty(t.prototype,"worldPos",{get:function(){return this.collider&&this.collider.body?this.collider.body.pos.add(this.offset):this.offset},enumerable:!1,configurable:!0}),t.prototype.clone=function(){return new t({offset:this.offset.clone(),radius:this.radius,collider:null})},Object.defineProperty(t.prototype,"center",{get:function(){return this.collider&&this.collider.body?this.offset.add(this.collider.body.pos):this.offset},enumerable:!1,configurable:!0}),t.prototype.contains=function(t){var e=this.offset;return this.collider&&this.collider.body&&(e=this.collider.body.pos),e.distance(t)<=this.radius},t.prototype.rayCast=function(t,e){void 0===e&&(e=1/0);var o=this.center,i=t.dir,r=t.pos,s=Math.sqrt(Math.pow(i.dot(r.sub(o)),2)-Math.pow(r.sub(o).distance(),2)+Math.pow(this.radius,2));if(s<0)return null;var n=0;if(0===s)return(n=-i.dot(r.sub(o)))>0&&n<e?t.getPoint(n):null;var l=-i.dot(r.sub(o))+s,a=-i.dot(r.sub(o))-s,u=[];l>=0&&u.push(l),a>=0&&u.push(a);var f=Math.min.apply(Math,u);return f<=e?t.getPoint(f):null},t.prototype.getClosestLineBetween=function(e){if(e instanceof t)return ClosestLineJumpTable.CircleCircleClosestLine(this,e);if(e instanceof ConvexPolygon)return ClosestLineJumpTable.PolygonCircleClosestLine(e,this).flip();if(e instanceof Edge)return ClosestLineJumpTable.CircleEdgeClosestLine(this,e).flip();throw new Error("Polygon could not collide with unknown CollisionShape "+typeof e)},t.prototype.collide=function(e){if(e instanceof t)return CollisionJumpTable.CollideCircleCircle(this,e);if(e instanceof ConvexPolygon)return CollisionJumpTable.CollideCirclePolygon(this,e);if(e instanceof Edge)return CollisionJumpTable.CollideCircleEdge(this,e);throw new Error("Circle could not collide with unknown CollisionShape "+typeof e)},t.prototype.getFurthestPoint=function(t){return this.center.add(t.normalize().scale(this.radius))},Object.defineProperty(t.prototype,"bounds",{get:function(){var t=Vector.Zero;return this.collider&&this.collider.body&&(t=this.collider.body.pos),new BoundingBox(this.offset.x+t.x-this.radius,this.offset.y+t.y-this.radius,this.offset.x+t.x+this.radius,this.offset.y+t.y+this.radius)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"localBounds",{get:function(){return new BoundingBox(this.offset.x-this.radius,this.offset.y-this.radius,this.offset.x+this.radius,this.offset.y+this.radius)},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"axes",{get:function(){return null},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"inertia",{get:function(){return(this.collider?this.collider.mass:Physics.defaultMass)*this.radius*this.radius/2},enumerable:!1,configurable:!0}),t.prototype.testSeparatingAxisTheorem=function(t){var e=t.axes,o=t.center,i=t.getFurthestPoint(this.offset.sub(o));e.push(this.offset.sub(i).normalize());for(var r=Number.MAX_VALUE,s=null,n=-1,l=0;l<e.length;l++){var a=t.project(e[l]),u=this.project(e[l]),f=a.getOverlap(u);if(f<=0)return null;f<r&&(r=f,s=e[l],n=l)}return n<0?null:s.normalize().scale(r)},t.prototype.recalc=function(){},t.prototype.project=function(t){var e=[],o=this.center.dot(t);return e.push(o),e.push(o+this.radius),e.push(o-this.radius),new Projection(Math.min.apply(Math,e),Math.max.apply(Math,e))},t.prototype.draw=function(t,e,o){void 0===e&&(e=Color.Green),void 0===o&&(o=Vector.Zero);var i=o.add(this.offset);t.beginPath(),t.fillStyle=e.toString(),t.arc(i.x,i.y,this.radius,0,2*Math.PI),t.closePath(),t.fill()},t.prototype.debugDraw=function(t,e){void 0===e&&(e=Color.Green);var o=this.collider.body,i=o?o.pos.add(this.offset):this.offset,r=o?o.rotation:0;t.beginPath(),t.strokeStyle=e.toString(),t.arc(i.x,i.y,this.radius,0,2*Math.PI),t.closePath(),t.stroke(),t.beginPath(),t.moveTo(i.x,i.y),t.lineTo(Math.cos(r)*this.radius+i.x,Math.sin(r)*this.radius+i.y),t.closePath(),t.stroke()},t}();export{Circle};