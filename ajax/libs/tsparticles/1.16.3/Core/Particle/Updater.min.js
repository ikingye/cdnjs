"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Updater=void 0;const Utils_1=require("../../Utils"),Mover_1=require("./Mover"),Enums_1=require("../../Enums");class Updater{constructor(t,e){this.container=t,this.particle=e,this.mover=new Mover_1.Mover(t,e)}static checkBounds(t,e,i,o,s){(t+e>i&&o>0||t-e<0&&o<0)&&s()}update(t){this.mover.move(t),this.updateOpacity(t),this.updateSize(t),this.updateAngle(t),this.updateColor(t),this.fixOutOfCanvasPosition(),this.updateOutMode(t)}updateOpacity(t){const e=this.container.options,i=this.particle,o=e.fpsLimit>0?60*t/1e3:3.6;if(i.particlesOptions.opacity.animation.enable){switch(i.opacity.status){case Enums_1.OpacityAnimationStatus.increasing:i.opacity.value>=i.particlesOptions.opacity.value?i.opacity.status=Enums_1.OpacityAnimationStatus.decreasing:i.opacity.value+=(i.opacity.velocity||0)*o;break;case Enums_1.OpacityAnimationStatus.decreasing:i.opacity.value<=i.particlesOptions.opacity.animation.minimumValue?i.opacity.status=Enums_1.OpacityAnimationStatus.increasing:i.opacity.value-=(i.opacity.velocity||0)*o}i.opacity.value<0&&(i.opacity.value=0)}}updateSize(t){var e;const i=this.container,o=i.options,s=this.particle,a=o.fpsLimit>0?60*t/1e3:3.6,n=s.particlesOptions.size,c=n.animation;if(c.enable){switch(s.size.status){case Enums_1.SizeAnimationStatus.increasing:s.size.value>=(null!==(e=s.sizeValue)&&void 0!==e?e:i.retina.sizeValue)?s.size.status=Enums_1.SizeAnimationStatus.decreasing:s.size.value+=(s.size.velocity||0)*a;break;case Enums_1.SizeAnimationStatus.decreasing:s.size.value<=c.minimumValue?s.size.status=Enums_1.SizeAnimationStatus.increasing:s.size.value-=(s.size.velocity||0)*a}switch(c.destroy){case Enums_1.DestroyType.max:s.size.value>=n.value*i.retina.pixelRatio&&s.destroy();break;case Enums_1.DestroyType.min:s.size.value<=c.minimumValue*i.retina.pixelRatio&&s.destroy()}s.size.value<0&&!s.destroyed&&(s.size.value=0)}}updateAngle(t){const e=this.container.options,i=this.particle,o=e.fpsLimit>0?60*t/1e3:3.6;if(i.particlesOptions.rotate.animation.enable)switch(i.rotateDirection){case Enums_1.RotateDirection.clockwise:i.angle+=i.particlesOptions.rotate.animation.speed*Math.PI/18*o,i.angle>360&&(i.angle-=360);break;case Enums_1.RotateDirection.counterClockwise:default:i.angle-=i.particlesOptions.rotate.animation.speed*Math.PI/18*o,i.angle<0&&(i.angle+=360)}}updateColor(t){const e=this.container.options,i=this.particle;if(void 0===i.color)return;const o=e.fpsLimit>0?60*t/1e3:3.6;i.particlesOptions.color.animation.enable&&(i.color.h+=(i.colorVelocity||0)*o,i.color.h>360&&(i.color.h-=360))}fixOutOfCanvasPosition(){const t=this.container,e=this.particle,i=e.particlesOptions.move.outMode,o=e.particlesOptions.move.warp,s=t.canvas.size;let a;if(a=i===Enums_1.OutMode.bounce?{bottom:s.height,left:e.size.value,right:s.width,top:e.size.value}:i===Enums_1.OutMode.bounceHorizontal?{bottom:s.height+e.size.value-e.offset.y,left:e.size.value,right:s.width,top:-e.size.value-e.offset.y}:i===Enums_1.OutMode.bounceVertical?{bottom:s.height,left:-e.size.value-e.offset.x,right:s.width+e.size.value+e.offset.x,top:e.size.value}:{bottom:s.height+e.size.value-e.offset.y,left:-e.size.value-e.offset.x,right:s.width+e.size.value+e.offset.x,top:-e.size.value-e.offset.y},i===Enums_1.OutMode.destroy){const i=e.size.value;Utils_1.Utils.isPointInside(e.position,t.canvas.size,i)||t.particles.remove(e)}else{const t=e.size.value,i=Utils_1.Utils.calculateBounds(e.position,t);i.left>s.width-e.offset.x?(e.position.x=a.left,o||(e.position.y=Math.random()*s.height)):i.right<-e.offset.x&&(e.position.x=a.right,o||(e.position.y=Math.random()*s.height)),i.top>s.height-e.offset.y?(o||(e.position.x=Math.random()*s.width),e.position.y=a.top):i.bottom<-e.offset.y&&(o||(e.position.x=Math.random()*s.width),e.position.y=a.bottom)}}updateOutMode(t){switch(this.particle.particlesOptions.move.outMode){case Enums_1.OutMode.bounce:case Enums_1.OutMode.bounceVertical:case Enums_1.OutMode.bounceHorizontal:this.updateBounce(t)}}updateBounce(t){const e=this.container,i=this.particle;let o=!1;for(const[,s]of e.plugins)if(void 0!==s.particleBounce&&(o=s.particleBounce(i,t)),o)break;if(!o){const t=i.particlesOptions.move.outMode,o=i.getPosition();if(t===Enums_1.OutMode.bounce||t===Enums_1.OutMode.bounceHorizontal){const t=i.size.value,s=i.velocity.horizontal;Updater.checkBounds(o.x,t,e.canvas.size.width,s,()=>{i.velocity.horizontal*=-1})}if(t===Enums_1.OutMode.bounce||t===Enums_1.OutMode.bounceVertical){const t=i.size.value,s=i.velocity.vertical;Updater.checkBounds(o.y,t,e.canvas.size.height,s,()=>{i.velocity.vertical*=-1})}}}}exports.Updater=Updater;