"use strict";const Avvio=require("avvio"),http=require("http"),querystring=require("querystring");let lightMyRequest;const{kAvvioBoot:kAvvioBoot,kChildren:kChildren,kBodyLimit:kBodyLimit,kRoutePrefix:kRoutePrefix,kLogLevel:kLogLevel,kLogSerializers:kLogSerializers,kHooks:kHooks,kSchemas:kSchemas,kSchemaCompiler:kSchemaCompiler,kSchemaResolver:kSchemaResolver,kReplySerializerDefault:kReplySerializerDefault,kContentTypeParser:kContentTypeParser,kReply:kReply,kRequest:kRequest,kMiddlewares:kMiddlewares,kFourOhFour:kFourOhFour,kState:kState,kOptions:kOptions,kGlobalHooks:kGlobalHooks,kPluginNameChain:kPluginNameChain}=require("./lib/symbols.js"),{createServer:createServer}=require("./lib/server"),Reply=require("./lib/reply"),Request=require("./lib/request"),supportedMethods=["DELETE","GET","HEAD","PATCH","POST","PUT","OPTIONS"],decorator=require("./lib/decorate"),ContentTypeParser=require("./lib/contentTypeParser"),{Hooks:Hooks,buildHooks:buildHooks,hookRunnerApplication:hookRunnerApplication}=require("./lib/hooks"),{Schemas:Schemas,buildSchemas:buildSchemas}=require("./lib/schemas"),{createLogger:createLogger}=require("./lib/logger"),pluginUtils=require("./lib/pluginUtils"),reqIdGenFactory=require("./lib/reqIdGenFactory"),{buildRouting:buildRouting,validateBodyLimitOption:validateBodyLimitOption}=require("./lib/route"),build404=require("./lib/fourOhFour"),getSecuredInitialConfig=require("./lib/initialConfigValidation"),{defaultInitOptions:defaultInitOptions}=getSecuredInitialConfig,{codes:{FST_ERR_BAD_URL:FST_ERR_BAD_URL}}=require("./lib/errors");function build(e){if("object"!=typeof(e=e||{}))throw new TypeError("Options must be an object");if(e.querystringParser&&"function"!=typeof e.querystringParser)throw new Error(`querystringParser option should be a function, instead got '${typeof e.querystringParser}'`);validateBodyLimitOption(e.bodyLimit),e.logger&&e.logger.genReqId&&(process.emitWarning("Using 'genReqId' in logger options is deprecated. Use fastify options instead. See: https://www.fastify.io/docs/latest/Server/#gen-request-id"),e.genReqId=e.logger.genReqId);const t=!1!==e.modifyCoreObjects,r=e.requestIdHeader||defaultInitOptions.requestIdHeader,o=e.querystringParser||querystring.parse,i=e.genReqId||reqIdGenFactory(),n=e.requestIdLogLabel||"reqId",s=e.bodyLimit||defaultInitOptions.bodyLimit,a=e.disableRequestLogging||!1,l=Object.assign({customOptions:{},plugins:[]},e.ajv),u=e.frameworkErrors;if(!l.customOptions||"[object Object]"!==Object.prototype.toString.call(l.customOptions))throw new Error(`ajv.customOptions option should be an object, instead got '${typeof l.customOptions}'`);if(!l.plugins||!Array.isArray(l.plugins))throw new Error(`ajv.plugins option should be an array, instead got '${typeof l.customOptions}'`);l.plugins=l.plugins.map(e=>Array.isArray(e)?e:[e]);const{logger:c,hasLogger:d}=createLogger(e);e.logger=c,e.modifyCoreObjects=t,e.genReqId=i,e.requestIdHeader=r,e.querystringParser=o,e.requestIdLogLabel=n,e.modifyCoreObjects=t,e.disableRequestLogging=a,e.ajv=l;const h=getSecuredInitialConfig(e),g=buildRouting({config:{defaultRoute:function(e,t){void 0!==e.headers["accept-version"]&&(e.headers["accept-version"]=void 0);p.router.lookup(e,t)},onBadUrl:function(e,r,o){if(u){r.id=i(r),r.originalUrl=r.url;var n=c.child({reqId:r.id});t&&(r.log=o.log=n),n.info({req:r},"incoming request");const s=new Request(null,r,null,r.headers,n),a=new Reply(o,{onSend:[],onError:[]},s,n);return u(new FST_ERR_BAD_URL(e),s,a)}const s=`{"error":"Bad Request","message":"'${e}' is not a valid url component","statusCode":400}`;o.writeHead(400,{"Content-Type":"application/json","Content-Length":s.length}),o.end(s)},ignoreTrailingSlash:e.ignoreTrailingSlash||defaultInitOptions.ignoreTrailingSlash,maxParamLength:e.maxParamLength||defaultInitOptions.maxParamLength,caseSensitive:e.caseSensitive,versioning:e.versioning}}),p=build404(e),k=g.routing;e.http2SessionTimeout=h.http2SessionTimeout;const{server:f,listen:y}=createServer(e,k);f.on("clientError",function(e,t){const r=JSON.stringify({error:http.STATUS_CODES[400],message:"Client Error",statusCode:400});c.trace({err:e},"client error"),t.end(`HTTP/1.1 400 Bad Request\r\nContent-Length: ${r.length}\r\nContent-Type: application/json\r\n\r\n${r}`)});const m=Reply.setupResponseListeners,R=new Schemas,S={[kState]:{listening:!1,closing:!1,started:!1},[kOptions]:e,[kChildren]:[],[kBodyLimit]:s,[kRoutePrefix]:"",[kLogLevel]:"",[kLogSerializers]:null,[kHooks]:new Hooks,[kSchemas]:R,[kSchemaCompiler]:null,[kSchemaResolver]:null,[kReplySerializerDefault]:null,[kContentTypeParser]:new ContentTypeParser(s,e.onProtoPoisoning||defaultInitOptions.onProtoPoisoning,e.onConstructorPoisoning||defaultInitOptions.onConstructorPoisoning),[kReply]:Reply.buildReply(Reply),[kRequest]:Request.buildRequest(Request),[kMiddlewares]:[],[kFourOhFour]:p,[kGlobalHooks]:{onRoute:[],onRegister:[]},[pluginUtils.registeredPlugins]:[],[kPluginNameChain]:[],[kAvvioBoot]:null,delete:function(e,t,r){return g.prepareRoute.call(this,"DELETE",e,t,r)},get:function(e,t,r){return g.prepareRoute.call(this,"GET",e,t,r)},head:function(e,t,r){return g.prepareRoute.call(this,"HEAD",e,t,r)},patch:function(e,t,r){return g.prepareRoute.call(this,"PATCH",e,t,r)},post:function(e,t,r){return g.prepareRoute.call(this,"POST",e,t,r)},put:function(e,t,r){return g.prepareRoute.call(this,"PUT",e,t,r)},options:function(e,t,r){return g.prepareRoute.call(this,"OPTIONS",e,t,r)},all:function(e,t,r){return g.prepareRoute.call(this,supportedMethods,e,t,r)},route:function(e){return g.route.call(this,e)},log:c,addHook:function(e,t){if(q('Cannot call "addHook" when fastify instance is already started!'),"onSend"===e||"preSerialization"===e||"onError"===e)"AsyncFunction"===t.constructor.name&&4===t.length&&S.log.warn("Async function has too many arguments. Async hooks should not use the 'next' argument.",(new Error).stack);else if("onReady"===e){if("AsyncFunction"===t.constructor.name&&0!==t.length)throw new Error("Async function has too many arguments. Async hooks should not use the 'done' argument.")}else"AsyncFunction"===t.constructor.name&&3===t.length&&S.log.warn("Async function has too many arguments. Async hooks should not use the 'next' argument.",(new Error).stack);"onClose"===e?(this[kHooks].validate(e,t),this.onClose(t)):"onRoute"===e?(this[kHooks].validate(e,t),this[kGlobalHooks].onRoute.push(t)):"onRegister"===e?(this[kHooks].validate(e,t),this[kGlobalHooks].onRegister.push(t)):"onReady"===e?(this[kHooks].validate(e,t),this[kHooks].add(e,t)):this.after((r,o)=>{(function e(t,r){this[kHooks].add(t,r.bind(this));this[kChildren].forEach(o=>e.call(o,t,r))}).call(this,e,t),o(r)});return this},addSchema:function(e){return q('Cannot call "addSchema" when fastify instance is already started!'),this[kSchemas].add(e),this[kChildren].forEach(t=>t.addSchema(e)),this},getSchemas:R.getSchemas.bind(R),setSchemaCompiler:function(e){return q('Cannot call "setSchemaCompiler" when fastify instance is already started!'),this[kSchemaCompiler]=e,this},setSchemaResolver:function(e){return q('Cannot call "setSchemaResolver" when fastify instance is already started!'),this[kSchemaResolver]=e,this},setReplySerializer:function(e){return q('Cannot call "setReplySerializer" when fastify instance is already started!'),this[kReplySerializerDefault]=e,this},addContentTypeParser:ContentTypeParser.helpers.addContentTypeParser,hasContentTypeParser:ContentTypeParser.helpers.hasContentTypeParser,register:null,after:null,ready:null,onClose:null,close:null,listen:y,server:f,decorate:decorator.add,hasDecorator:decorator.exist,decorateReply:decorator.decorateReply,decorateRequest:decorator.decorateRequest,hasRequestDecorator:decorator.existRequest,hasReplyDecorator:decorator.existReply,use:function(e,t){if(q('Cannot call "use" when fastify instance is already started!'),"string"==typeof e){const t=this[kRoutePrefix];e=t+("/"===e&&t.length>0?"":e)}return this.after((r,o)=>{(function e(t){this[kMiddlewares].push(t);this[kChildren].forEach(r=>e.call(r,t))}).call(this,[e,t]),o(r)})},inject:function(e,t){void 0===lightMyRequest&&(lightMyRequest=require("light-my-request"));if(S[kState].started){if(S[kState].closing){const e=new Error("Server is closed");return t?void t(e):Promise.reject(e)}return lightMyRequest(k,e,t)}if(!t)return this.ready().then(()=>lightMyRequest(k,e));this.ready(r=>{r?t(r,null):lightMyRequest(k,e,t)})},printRoutes:g.printRoutes,setNotFoundHandler:function(e,t){q('Cannot call "setNotFoundHandler" when fastify instance is already started!'),p.setNotFoundHandler.call(this,e,t,b,g.routeHandler)},setErrorHandler:function(e){return q('Cannot call "setErrorHandler" when fastify instance is already started!'),this._errorHandler=e.bind(this),this},initialConfig:h};Object.defineProperty(S,"schemaCompiler",{get:function(){return this[kSchemaCompiler]},set:function(e){this.setSchemaCompiler(e)}}),Object.defineProperty(S,"prefix",{get:function(){return this[kRoutePrefix]}}),Object.defineProperty(S,"basePath",{get:function(){return process.emitWarning("basePath is deprecated. Use prefix instead. See: https://www.fastify.io/docs/latest/Server/#prefix"),this[kRoutePrefix]}}),Object.defineProperty(S,"pluginName",{get:function(){return this[kPluginNameChain].length>1?this[kPluginNameChain].join(" -> "):this[kPluginNameChain][0]}});const b=Avvio(S,{autostart:!1,timeout:Number(e.pluginTimeout)||defaultInitOptions.pluginTimeout,expose:{use:"register"}});return b.override=override,b.on("start",()=>S[kState].started=!0),S[kAvvioBoot]=S.ready,S.ready=function(e){let t,r;if(process.nextTick(function(){S[kAvvioBoot]((e,t)=>{e||S[kState].started?o(e):hookRunnerApplication("onReady",S[kAvvioBoot],S,o),t()})}),!e)return new Promise(function(e,o){t=e,r=o});function o(o){if(e)o?e(o):e(void 0,S);else{if(o)return r(o);t(S)}}},b.once("preReady",()=>{S.onClose((e,t)=>{S[kState].closing=!0,g.closeRoutes(),S[kState].listening?e.server.close(t):t(null)})}),S.setNotFoundHandler(),p.arrange404(S),g.setup(e,{avvio:b,fourOhFour:p,logger:c,hasLogger:d,setupResponseListeners:m,throwIfAlreadyStarted:q}),S;function q(e){if(S[kState].started)throw new Error(e)}}function override(e,t,r){if(pluginUtils.registerPlugin.call(e,t))return e[kPluginNameChain].push(pluginUtils.getDisplayName(t)),e;const o=Object.create(e);e[kChildren].push(o),o.ready=e[kAvvioBoot].bind(o),o[kChildren]=[],o[kReply]=Reply.buildReply(o[kReply]),o[kRequest]=Request.buildRequest(o[kRequest]),o[kContentTypeParser]=ContentTypeParser.helpers.buildContentTypeParser(o[kContentTypeParser]),o[kHooks]=buildHooks(o[kHooks]),o[kRoutePrefix]=buildRoutePrefix(o[kRoutePrefix],r.prefix),o[kLogLevel]=r.logLevel||o[kLogLevel],o[kMiddlewares]=e[kMiddlewares].slice(),o[kSchemas]=buildSchemas(e[kSchemas]),o.getSchemas=o[kSchemas].getSchemas.bind(o[kSchemas]),o[pluginUtils.registeredPlugins]=Object.create(o[pluginUtils.registeredPlugins]),o[kPluginNameChain]=[pluginUtils.getPluginName(t)||pluginUtils.getFuncPreview(t)],(o[kLogSerializers]||r.logSerializers)&&(o[kLogSerializers]=Object.assign(Object.create(o[kLogSerializers]),r.logSerializers)),r.prefix&&o[kFourOhFour].arrange404(o);for(const e of o[kGlobalHooks].onRegister)e.call(this,o,r);return o}function buildRoutePrefix(e,t){return t?(e.endsWith("/")?"/"===t[0]&&(t=t.slice(1)):"/"!==t[0]&&(t="/"+t),e+t):e}module.exports=build;