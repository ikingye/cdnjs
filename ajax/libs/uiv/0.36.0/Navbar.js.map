{"version":3,"file":"Navbar.js","sources":["../src/utils/domUtils.js","../src/components/collapse/Collapse.vue","../src/components/navbar/Navbar.vue"],"sourcesContent":["import {isExist, isString, isFunction} from './objectUtils'\n\nexport const EVENTS = {\n  MOUSE_ENTER: 'mouseenter',\n  MOUSE_LEAVE: 'mouseleave',\n  MOUSE_DOWN: 'mousedown',\n  MOUSE_UP: 'mouseup',\n  FOCUS: 'focus',\n  BLUR: 'blur',\n  CLICK: 'click',\n  INPUT: 'input',\n  KEY_DOWN: 'keydown',\n  KEY_UP: 'keyup',\n  KEY_PRESS: 'keypress',\n  RESIZE: 'resize',\n  SCROLL: 'scroll',\n  TOUCH_START: 'touchstart',\n  TOUCH_END: 'touchend'\n}\n\nexport const TRIGGERS = {\n  CLICK: 'click',\n  HOVER: 'hover',\n  FOCUS: 'focus',\n  HOVER_FOCUS: 'hover-focus',\n  OUTSIDE_CLICK: 'outside-click',\n  MANUAL: 'manual'\n}\n\nexport const PLACEMENTS = {\n  TOP: 'top',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  LEFT: 'left'\n}\n\nexport function isIE11 () {\n  return !!window.MSInputMethodContext && !!document.documentMode\n}\n\nexport function isIE10 () {\n  return window.navigator.appVersion.indexOf('MSIE 10') !== -1\n}\n\nexport function getComputedStyle (el) {\n  return window.getComputedStyle(el)\n}\n\nexport function getViewportSize () {\n  let width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)\n  let height = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)\n  return {width, height}\n}\n\nlet scrollbarWidth = null\nlet savedScreenSize = null\n\nexport function getScrollbarWidth (recalculate = false) {\n  let screenSize = getViewportSize()\n  // return directly when already calculated & not force recalculate & screen size not changed\n  if (scrollbarWidth !== null && !recalculate &&\n    screenSize.height === savedScreenSize.height && screenSize.width === savedScreenSize.width) {\n    return scrollbarWidth\n  }\n  if (document.readyState === 'loading') {\n    return null\n  }\n  const div1 = document.createElement('div')\n  const div2 = document.createElement('div')\n  div1.style.width = div2.style.width = div1.style.height = div2.style.height = '100px'\n  div1.style.overflow = 'scroll'\n  div2.style.overflow = 'hidden'\n  document.body.appendChild(div1)\n  document.body.appendChild(div2)\n  scrollbarWidth = Math.abs(div1.scrollHeight - div2.scrollHeight)\n  document.body.removeChild(div1)\n  document.body.removeChild(div2)\n  // save new screen size\n  savedScreenSize = screenSize\n  return scrollbarWidth\n}\n\nexport function on (element, event, handler) {\n  element.addEventListener(event, handler)\n}\n\nexport function off (element, event, handler) {\n  element.removeEventListener(event, handler)\n}\n\nexport function isElement (el) {\n  return el && el.nodeType === Node.ELEMENT_NODE\n}\n\nexport function removeFromDom (el) {\n  isElement(el) && isElement(el.parentNode) && el.parentNode.removeChild(el)\n}\n\nexport function ensureElementMatchesFunction () {\n  if (!Element.prototype.matches) {\n    Element.prototype.matches =\n      Element.prototype.matchesSelector ||\n      Element.prototype.mozMatchesSelector ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.oMatchesSelector ||\n      Element.prototype.webkitMatchesSelector ||\n      function (s) {\n        let matches = (this.document || this.ownerDocument).querySelectorAll(s)\n        let i = matches.length\n        while (--i >= 0 && matches.item(i) !== this) {\n        }\n        return i > -1\n      }\n  }\n}\n\nexport function addClass (el, className) {\n  if (!isElement(el)) {\n    return\n  }\n  if (el.className) {\n    let classes = el.className.split(' ')\n    if (classes.indexOf(className) < 0) {\n      classes.push(className)\n      el.className = classes.join(' ')\n    }\n  } else {\n    el.className = className\n  }\n}\n\nexport function removeClass (el, className) {\n  if (!isElement(el)) {\n    return\n  }\n  if (el.className) {\n    let classes = el.className.split(' ')\n    let newClasses = []\n    for (let i = 0, l = classes.length; i < l; i++) {\n      if (classes[i] !== className) {\n        newClasses.push(classes[i])\n      }\n    }\n    el.className = newClasses.join(' ')\n  }\n}\n\nexport function hasClass (el, className) {\n  if (!isElement(el)) {\n    return false\n  }\n  let classes = el.className.split(' ')\n  for (let i = 0, l = classes.length; i < l; i++) {\n    if (classes[i] === className) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function setDropdownPosition (dropdown, trigger, options = {}) {\n  let doc = document.documentElement\n  let containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0)\n  let containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n  let rect = trigger.getBoundingClientRect()\n  let dropdownRect = dropdown.getBoundingClientRect()\n  dropdown.style.right = 'auto'\n  dropdown.style.bottom = 'auto'\n  if (options.menuRight) {\n    dropdown.style.left = containerScrollLeft + rect.left + rect.width - dropdownRect.width + 'px'\n  } else {\n    dropdown.style.left = containerScrollLeft + rect.left + 'px'\n  }\n  if (options.dropup) {\n    dropdown.style.top = containerScrollTop + rect.top - dropdownRect.height - 4 + 'px'\n  } else {\n    dropdown.style.top = containerScrollTop + rect.top + rect.height + 'px'\n  }\n}\n\nexport function isAvailableAtPosition (trigger, popup, placement) {\n  let triggerRect = trigger.getBoundingClientRect()\n  let popupRect = popup.getBoundingClientRect()\n  let viewPortSize = getViewportSize()\n  let top = true\n  let right = true\n  let bottom = true\n  let left = true\n  switch (placement) {\n    case PLACEMENTS.TOP:\n      top = triggerRect.top >= popupRect.height\n      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2\n      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width\n      break\n    case PLACEMENTS.BOTTOM:\n      bottom = triggerRect.bottom + popupRect.height <= viewPortSize.height\n      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2\n      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width\n      break\n    case PLACEMENTS.RIGHT:\n      right = triggerRect.right + popupRect.width <= viewPortSize.width\n      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2\n      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height\n      break\n    case PLACEMENTS.LEFT:\n      left = triggerRect.left >= popupRect.width\n      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2\n      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height\n      break\n  }\n  return top && right && bottom && left\n}\n\nexport function setTooltipPosition (tooltip, trigger, placement, auto, appendToSelector, viewport) {\n  if (!isElement(tooltip) || !isElement(trigger)) {\n    return\n  }\n  const isPopover = tooltip && tooltip.className && tooltip.className.indexOf('popover') >= 0\n  let containerScrollTop\n  let containerScrollLeft\n  if (!isExist(appendToSelector) || appendToSelector === 'body') {\n    const doc = document.documentElement\n    containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0)\n    containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n  } else {\n    const container = document.querySelector(appendToSelector)\n    containerScrollLeft = container.scrollLeft\n    containerScrollTop = container.scrollTop\n  }\n  // auto adjust placement\n  if (auto) {\n    // Try: right -> bottom -> left -> top\n    // Cause the default placement is top\n    let placements = [PLACEMENTS.RIGHT, PLACEMENTS.BOTTOM, PLACEMENTS.LEFT, PLACEMENTS.TOP]\n    // The class switch helper function\n    const changePlacementClass = (placement) => {\n      // console.log(placement)\n      placements.forEach(placement => {\n        removeClass(tooltip, placement)\n      })\n      addClass(tooltip, placement)\n    }\n    // No need to adjust if the default placement fits\n    if (!isAvailableAtPosition(trigger, tooltip, placement)) {\n      for (let i = 0, l = placements.length; i < l; i++) {\n        // Re-assign placement class\n        changePlacementClass(placements[i])\n        // Break if new placement fits\n        if (isAvailableAtPosition(trigger, tooltip, placements[i])) {\n          placement = placements[i]\n          break\n        }\n      }\n      changePlacementClass(placement)\n    }\n  }\n  // fix left and top for tooltip\n  let rect = trigger.getBoundingClientRect()\n  let tooltipRect = tooltip.getBoundingClientRect()\n  let top\n  let left\n  if (placement === PLACEMENTS.BOTTOM) {\n    top = containerScrollTop + rect.top + rect.height\n    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2\n  } else if (placement === PLACEMENTS.LEFT) {\n    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2\n    left = containerScrollLeft + rect.left - tooltipRect.width\n  } else if (placement === PLACEMENTS.RIGHT) {\n    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2\n    // https://github.com/wxsms/uiv/issues/272\n    // add 1px to fix above issue\n    left = containerScrollLeft + rect.left + rect.width + 1\n  } else {\n    top = containerScrollTop + rect.top - tooltipRect.height\n    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2\n  }\n  let viewportEl\n  // viewport option\n  if (isString(viewport)) {\n    viewportEl = document.querySelector(viewport)\n  } else if (isFunction(viewport)) {\n    viewportEl = viewport(trigger)\n  }\n  if (isElement(viewportEl)) {\n    const popoverFix = isPopover ? 11 : 0\n    const viewportReact = viewportEl.getBoundingClientRect()\n    const viewportTop = containerScrollTop + viewportReact.top\n    const viewportLeft = containerScrollLeft + viewportReact.left\n    const viewportBottom = viewportTop + viewportReact.height\n    const viewportRight = viewportLeft + viewportReact.width\n    // fix top\n    if (top < viewportTop) {\n      top = viewportTop\n    } else if (top + tooltipRect.height > viewportBottom) {\n      top = viewportBottom - tooltipRect.height\n    }\n    // fix left\n    if (left < viewportLeft) {\n      left = viewportLeft\n    } else if (left + tooltipRect.width > viewportRight) {\n      left = viewportRight - tooltipRect.width\n    }\n    // fix for popover pointer\n    if (placement === PLACEMENTS.BOTTOM) {\n      top -= popoverFix\n    } else if (placement === PLACEMENTS.LEFT) {\n      left += popoverFix\n    } else if (placement === PLACEMENTS.RIGHT) {\n      left -= popoverFix\n    } else {\n      top += popoverFix\n    }\n  }\n  // set position finally\n  tooltip.style.top = `${top}px`\n  tooltip.style.left = `${left}px`\n}\n\nexport function hasScrollbar (el) {\n  const SCROLL = 'scroll'\n  const hasVScroll = el.scrollHeight > el.clientHeight\n  const style = getComputedStyle(el)\n  return hasVScroll || style.overflow === SCROLL || style.overflowY === SCROLL\n}\n\nexport function toggleBodyOverflow (enable) {\n  const MODAL_OPEN = 'modal-open'\n  const body = document.body\n  if (enable) {\n    removeClass(body, MODAL_OPEN)\n    body.style.paddingRight = null\n  } else {\n    const browsersWithFloatingScrollbar = isIE10() || isIE11()\n    const documentHasScrollbar = hasScrollbar(document.documentElement) || hasScrollbar(document.body)\n    if (documentHasScrollbar && !browsersWithFloatingScrollbar) {\n      body.style.paddingRight = `${getScrollbarWidth()}px`\n    }\n    addClass(body, MODAL_OPEN)\n  }\n}\n\nexport function getClosest (el, selector) {\n  ensureElementMatchesFunction()\n  let parent\n  let _el = el\n  while (_el) {\n    parent = _el.parentElement\n    if (parent && parent.matches(selector)) {\n      return parent\n    }\n    _el = parent\n  }\n  return null\n}\n\nexport function getParents (el, selector, until = null) {\n  ensureElementMatchesFunction()\n  let parents = []\n  let parent = el.parentElement\n  while (parent) {\n    if (parent.matches(selector)) {\n      parents.push(parent)\n    } else if (until && (until === parent || parent.matches(until))) {\n      break\n    }\n    parent = parent.parentElement\n  }\n  return parents\n}\n\nexport function focus (el) {\n  if (!isElement(el)) {\n    return\n  }\n  el.getAttribute('tabindex') ? null : el.setAttribute('tabindex', '-1')\n  el.focus()\n}\n","<script>\n  import {addClass, removeClass} from '../../utils/domUtils'\n\n  const COLLAPSE = 'collapse'\n  const IN = 'in'\n  const COLLAPSING = 'collapsing'\n\n  export default {\n    render (h) {\n      return h(this.tag, {}, this.$slots.default)\n    },\n    props: {\n      tag: {\n        type: String,\n        default: 'div'\n      },\n      value: {\n        type: Boolean,\n        default: false\n      },\n      transitionDuration: {\n        type: Number,\n        default: 350\n      }\n    },\n    data () {\n      return {\n        timeoutId: 0\n      }\n    },\n    watch: {\n      value (show) {\n        this.toggle(show)\n      }\n    },\n    mounted () {\n      let el = this.$el\n      addClass(el, COLLAPSE)\n      if (this.value) {\n        addClass(el, IN)\n      }\n    },\n    methods: {\n      toggle (show) {\n        clearTimeout(this.timeoutId)\n        let el = this.$el\n        if (show) {\n          this.$emit('show')\n          removeClass(el, COLLAPSE)\n          el.style.height = 'auto'\n          let height = window.getComputedStyle(el).height\n          el.style.height = null\n          addClass(el, COLLAPSING)\n          el.offsetHeight // force repaint\n          el.style.height = height\n          this.timeoutId = setTimeout(() => {\n            removeClass(el, COLLAPSING)\n            addClass(el, COLLAPSE)\n            addClass(el, IN)\n            el.style.height = null\n            this.timeoutId = 0\n            this.$emit('shown')\n          }, this.transitionDuration)\n        } else {\n          this.$emit('hide')\n          el.style.height = window.getComputedStyle(el).height\n          removeClass(el, IN)\n          removeClass(el, COLLAPSE)\n          el.offsetHeight\n          el.style.height = null\n          addClass(el, COLLAPSING)\n          this.timeoutId = setTimeout(() => {\n            addClass(el, COLLAPSE)\n            removeClass(el, COLLAPSING)\n            el.style.height = null\n            this.timeoutId = 0\n            this.$emit('hidden')\n          }, this.transitionDuration)\n        }\n      }\n    }\n  }\n</script>\n","<template>\n  <nav :class=\"navClasses\">\n    <div :class=\"fluid?'container-fluid':'container'\">\n      <div class=\"navbar-header\">\n        <slot name=\"collapse-btn\">\n          <button type=\"button\" class=\"navbar-toggle collapsed\" @click=\"toggle\">\n            <span class=\"sr-only\">Toggle navigation</span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n          </button>\n        </slot>\n        <slot name=\"brand\"/>\n      </div>\n      <slot/>\n      <collapse class=\"navbar-collapse\" v-model=\"show\">\n        <slot name=\"collapse\"/>\n      </collapse>\n    </div>\n  </nav>\n</template>\n\n<script>\n  import Collapse from '../collapse/Collapse.vue'\n\n  export default {\n    components: {Collapse},\n    props: {\n      value: Boolean,\n      fluid: {\n        type: Boolean,\n        default: true\n      },\n      fixedTop: Boolean,\n      fixedBottom: Boolean,\n      staticTop: Boolean,\n      inverse: Boolean\n    },\n    data () {\n      return {\n        show: false\n      }\n    },\n    computed: {\n      navClasses () {\n        return {\n          navbar: true,\n          'navbar-default': !this.inverse,\n          'navbar-inverse': this.inverse,\n          'navbar-static-top': this.staticTop,\n          'navbar-fixed-bottom': this.fixedBottom,\n          'navbar-fixed-top': this.fixedTop\n        }\n      }\n    },\n    mounted () {\n      this.show = !!this.value\n    },\n    watch: {\n      value (v) {\n        this.show = v\n      }\n    },\n    methods: {\n      toggle () {\n        this.show = !this.show\n        this.$emit('input', this.show)\n      }\n    }\n  }\n</script>\n"],"names":["isElement","el","nodeType","Node","ELEMENT_NODE","addClass","className","classes","split","indexOf","push","join","removeClass","newClasses","i","l","length","COLLAPSE","IN","COLLAPSING","h","tag","$slots","default","String","Boolean","Number","show","toggle","$el","value","timeoutId","$emit","style","height","window","getComputedStyle","offsetHeight","setTimeout","transitionDuration","render","Collapse","inverse","staticTop","fixedBottom","fixedTop","v"],"mappings":"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"}